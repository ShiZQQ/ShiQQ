[{"content":"Welcome to Hugo theme Stack. This is your first post. Edit or delete it, then start writing!\nFor more information about this theme, check the documentation: https://stack.jimmycai.com/\nWant a site like this? Check out hugo-theme-stack-stater\nPhoto by Pawel Czerwinski on Unsplash\n","date":"2022-03-06T00:00:00Z","image":"https://example.com/p/hello-world/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/hello-world/","title":"Hello World"},{"content":"","date":"2024-07-04T17:37:53+08:00","permalink":"https://example.com/p/test2/","title":"Test2"},{"content":"在忘记密码的情况下push或pull 在https连接的情况下push或pull会询问用户名和密码，每次输入用户密码会有点麻烦，所有我们可以使用SSH 来操作，公钥文件和私钥文件就成了我们免密验证的关键，以下是具体操作。\n生成公钥文件和私钥文件 1 2 3 ssh-keygen -t rsa -C \u0026#34;2837355374@qq.com\u0026#34; #`-t rsa`：指定生成的密钥类型是 RSA。RSA 是一种常见的公钥加密算法。# #上面的邮箱是绑定的邮箱，本次我们拿gitee举例 输入指令之后点三次回车键\n上面显示保存路径在 C:\\Users\\ShiQ/.ssh/id_rsa.\n复制id_rsa.pub中的内容\n配置gitee中SSH公钥 点击个人设置页面\n点击ssh公钥\n填写标题和公钥（刚才复制的内容）\n输入gitee密码即可完成设置\n再次pull代码时不会再询问用户名（邮箱）和密码\n","date":"2024-07-03T16:59:01+08:00","permalink":"https://example.com/p/git%E5%85%8D%E5%AF%86push/","title":"Git免密push"},{"content":"es6中的\u0026hellip; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //在这里...有一个组装的作用，把多余的参数组装成一个[] const fn = (a, b, c, ...d) =\u0026gt; { console.log(a, b, c, d) } // fn(1, 1, 1, 21, 22, 2, 22, [1, 2, 3, 3]) //在这里...有一个拆解[]的作用，把[1, 2, 3, 3, 3, 3, 3, 3, 3,]一个一个的传进去 fn(1, 2, 3, 8, 4, 2, 1, ...[1, 2, 3, 3, 3, 3, 3, 3, 3,]) // li = [1, 2, 3] fn([1, 2, 3]) // li = [1, 2, 3, [1, 2, 3]] fn(...[1, 2, 3]) //输出 1 2 3 [ 8, 4, 2, 1, 1, 2, 3, 3, 3, 3, 3, 3, 3 ] [ 1, 2, 3 ] undefined undefined [] 1 2 3 [] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 const li1 = [1, 2, 3] const li2 = [2, 3, 4] const li3 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] //把上面的数组展开合并并使用set去重 const li = new Set([...li1, ...li2, ...li3]) console.log(li) //输出 Set(7) { 1, 2, 3, 4, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39; } const li1 = [1, 2, 3] const li2 = [2, 3, 4] const li3 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] //把上面的数组展开合并并使用set去重 const li = [...new Set([...li1, ...li2, ...li3])] console.log(li) //输出 //set展开后的数组 [1, 2, 3, 4, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39; ] ","date":"2024-07-03T16:42:26+08:00","permalink":"https://example.com/p/es6%E4%B8%AD%E7%9A%84...%E6%93%8D%E4%BD%9C/","title":"Es6中的...操作"},{"content":"autorun的底层实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 const map = new Map() const obj = {} let currentFunc = null const p = new Proxy(obj, { get(target, p, receiver) { //实现依赖收集 if (currentFunc) { const s = map.get(p) || new Set() s.add(currentFunc) map.set(p,s) // map.set(p, [...(map.get(p) || []), currentFunc]) } // console.log(\u0026#39;我的\u0026#39;, p, \u0026#39;属性 被读取\u0026#39;) return target[p] }, set(target, p, newValue, receiver) { target[p] = newValue //取出map中的监听的东西，如果改变则重新跑一边存的函数 const callback = map.get(p); // console.log(callback) if (callback) { callback.forEach(fn =\u0026gt; fn()) } return true } }) const autorun = (fn) =\u0026gt; { //保存函数，就是() =\u0026gt; { // p.id // console.log(\u0026#39;监听到p.id变化\u0026#39;, p.id) //} currentFunc = fn fn() currentFunc = null // 1. 收集依赖 // 2. 监听这些依赖 } autorun(() =\u0026gt; { p.id console.log(\u0026#39;监听到p.id变化\u0026#39;, p.id) }) autorun(() =\u0026gt; { p.id console.log(\u0026#39;监听到p.id变化 2\u0026#39;, p.id) }) setInterval(() =\u0026gt; { p.id = (p.id || 0) + 1 // console.log(p.id) }, 1000) ","date":"2024-07-03T16:40:27+08:00","permalink":"https://example.com/p/autorun%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/","title":"Autorun的底层实现"},{"content":"多态 类似于函数不管传入的参数类型是什么，参数只要满足特定的条件就可以传入j\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package main import \u0026#34;fmt\u0026#34; type Animal struct { } type Person struct { //interface是描述需要的条件（其中的条件必须是方法） type Sayer interface { Say() Run() } func Run(s Sayer) { } func (a Animal) Say() { } func (a Person) Say() { } type Integer int func (x Integer) Say() { } func main() { var a = Animal{} var person = Person{} Run(a) Run(person) var x Integer = 1 var y = 1 fmt.Println(int(x) == y) Run(x) } ","date":"2024-07-03T16:38:27+08:00","permalink":"https://example.com/p/%E5%A4%9A%E6%80%81/","title":"多态"},{"content":"react的例子 关于react的核心思想：当状态（）确定了就确定了视图即声明式布局，为了好维护，传统的开发是命令式\n1 2 3 [变量，函数] //且不能放在循环和if里，只能放在顶层 const [count, setCount] = useState(0) setCount允许有两种参数，一种是直接传进一个变量，就是下一次要修改的值。\n一种是函数，它会将原来的变量值传入这个函数内，下次更新函数返回的值\n例子1 关于set*，setcount会进行合并，之后再进行对count赋值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 const App = () =\u0026gt; { const [count, setCount] = useState(0) const [count2, setCount2] = useState(0) function get(x) { console.log(x) return x + 1 } // set 之后 他不是马上更新视图的， 他会合并一些状态，　一次性更新　const add = () =\u0026gt; { // setCount((count) =\u0026gt; count + 1) for (let i = 0; i \u0026lt; 10; i++) { setCount(get) } //错误演示 for (let i = 0; i \u0026lt; 10; i++) { setCount2(count + 2) } } return \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; { add() }}\u0026gt; CLICK ME {count} CLICK ME {count2} \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; } useRef 1 2 const count = useRef(0) //只能保存，没有能使重新渲染 只有set*才能使重新渲染 关于const ref = useRef(null)的使用\n本身是一个对象，传递一个指针，为了防止冲突\n1 2 3 4 const ref = useRef(null) return \u0026lt;div style={{ aspectRatio: \u0026#39;4/3\u0026#39;, outline: \u0026#39;2px solid black\u0026#39; }} ref={ref}/\u0026gt; 冲突例子：如果引入的包中有id也命名为main时，就会发生冲突 return \u0026lt;div style={{ aspectRatio: \u0026#39;4/3\u0026#39;, outline: \u0026#39;2px solid black\u0026#39; }} id=\u0026#39;main\u0026#39;/\u0026gt; 也可以作为状态使用，跟随组件的生命周期，如果组件被初始化\n1 const ins = useRef\u0026lt;EChartsType | null\u0026gt;() 1 2 3 4 //监听某一个元素宽高的变化 const ob = useRef\u0026lt;ResizeObserver\u0026gt;() //监听某一个元素是否出现在屏幕内（isIntersecting） const ob2 = useRef\u0026lt;IntersectionObserver\u0026gt;() 关于useRef无法渲染的例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 //成功例子 const App = () =\u0026gt; { const count = useRef(0) const [_, setState] = useState(0) const add = () =\u0026gt; { count.current++ } //利用setState来渲染 const render = () =\u0026gt; { setState(c =\u0026gt; c + 1) } return \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; { add() }}\u0026gt; CLICK ME {count.current} \u0026lt;/button\u0026gt; \u0026lt;button onClick={render}\u0026gt; RENDER \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; } //无法渲染例子 const App = () =\u0026gt; { const count = useRef(0) const [_, setState] = useState(0) const add = () =\u0026gt; { count.current++ } return \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; { add() }}\u0026gt; CLICK ME {count.current} \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; } 所以有了useForcesUpdate，可以强制渲染\n1 2 3 4 const useForcesUpdate = () =\u0026gt; { const [_, setCount] = useState(0) return () =\u0026gt; setCount(c =\u0026gt; c + 1) } 关于list更新的例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 //失败例子 const App = () =\u0026gt; { const [list, setList] = useState([] as number[]) const push1 = () =\u0026gt; { setList((list) =\u0026gt; { list.push(1) return list }) } return \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; { push1() }}\u0026gt; CLICK ME \u0026lt;/button\u0026gt; {JSON.stringify(list)} \u0026lt;/div\u0026gt; } // return list后，react判断前后的值是一样的，他就不会重新渲染，我们需要一个中间量让react知道我们改变了， return [...list]类似于复制操作，改变了值，react会重新渲染 //成功的例子 const App = () =\u0026gt; { const [list, setList] = useState([] as number[]) const push1 = () =\u0026gt; { setList((list) =\u0026gt; { list.push(1) return [...list] }) } return \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; { push1() }}\u0026gt; CLICK ME \u0026lt;/button\u0026gt; {JSON.stringify(list)} \u0026lt;/div\u0026gt; } //另一种方法，因为react是只要有set*发生改变，就会渲染，不管是谁（这就是react的不问数据来源） const useForcesUpdate = () =\u0026gt; { const [_, setCount] = useState(0) return () =\u0026gt; setCount(c =\u0026gt; c + 1) } const App = () =\u0026gt; { const [list, setList] = useState([] as number[]) const forceUpdate = useForcesUpdate() const push1 = () =\u0026gt; { list.push(1) forceUpdate() } return \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; { push1() }}\u0026gt; CLICK ME \u0026lt;/button\u0026gt; {JSON.stringify(list)} \u0026lt;/div\u0026gt; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 const useForcesUpdate = () =\u0026gt; { const [_, setCount] = useState(0) return () =\u0026gt; setCount(c =\u0026gt; c + 1) } const list = [] const Counter = () =\u0026gt; { const forceUpdate = useForcesUpdate() return \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; list.push(1)}\u0026gt; PUSH \u0026lt;/button\u0026gt; //这一个forceUpdate的 \u0026lt;button onClick={forceUpdate}\u0026gt; Render \u0026lt;/button\u0026gt; {JSON.stringify(list)} \u0026lt;/div\u0026gt; } const App = () =\u0026gt; { const forceUpdate = useForcesUpdate() return \u0026lt;div\u0026gt; \u0026lt;button onClick={forceUpdate}\u0026gt;Render\u0026lt;/button\u0026gt; \u0026lt;Counter\u0026gt;\u0026lt;/Counter\u0026gt; \u0026lt;Counter\u0026gt;\u0026lt;/Counter\u0026gt; \u0026lt;/div\u0026gt; } 路由 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 const Nav = () =\u0026gt; { return \u0026lt;div\u0026gt; //主动去跳转路由 \u0026lt;Link to={\u0026#39;/\u0026#39;}\u0026gt;root\u0026lt;/Link\u0026gt; \u0026lt;Link to={\u0026#39;/demo2\u0026#39;}\u0026gt;demo2\u0026lt;/Link\u0026gt; \u0026lt;Link to={\u0026#39;/demo3\u0026#39;}\u0026gt;demo3\u0026lt;/Link\u0026gt; \u0026lt;/div\u0026gt; } 对应下面的element={\u0026lt;Layout/\u0026gt;} const Layout = () =\u0026gt; { const location = useLocation(); const navigate = useNavigate(); const [count, setCount] = useState([]) return \u0026lt;div\u0026gt; {/*这里是页头*/} \u0026lt;div\u0026gt; HEADER \u0026lt;/div\u0026gt; {/*此时的Outlet对应了下面的RootLayout或CommonLayout*/} \u0026lt;Outlet/\u0026gt; \u0026lt;div\u0026gt; FOOTER \u0026lt;/div\u0026gt; {/*这里是页脚*/} \u0026lt;/div\u0026gt; } const permissions = [ \u0026#39;user:add\u0026#39; ] //用来判断用户是否有某些权限 const hasPermission = (name) =\u0026gt; { return userStore.role == \u0026#39;root\u0026#39; || permissions.includes(name) } const RootLayout = () =\u0026gt; { return \u0026lt;div style={{ display: \u0026#34;flex\u0026#34; }}\u0026gt; \u0026lt;div style={{ width: 300 }}\u0026gt; 这里是root侧边栏 \u0026lt;/div\u0026gt; \u0026lt;div style={{ flex: 1 }}\u0026gt; {/* 此对应的是\u0026lt;Route path={\u0026#39;/\u0026#39;} element={\u0026lt;div/\u0026gt;}\u0026gt;\u0026lt;/Route\u0026gt; \u0026lt;Route path={\u0026#39;/demo2\u0026#39;} element={\u0026lt;App2/\u0026gt;}\u0026gt;\u0026lt;/Route\u0026gt; \u0026lt;Route path={\u0026#39;/demo3\u0026#39;} element={\u0026lt;App3/\u0026gt;}\u0026gt;\u0026lt;/Route\u0026gt;*/} \u0026lt;Outlet/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; } const CommonLayout = () =\u0026gt; { return \u0026lt;div style={{ display: \u0026#34;flex\u0026#34; }}\u0026gt; \u0026lt;div style={{ width: 300 }}\u0026gt; 这里是common 侧边栏 \u0026lt;/div\u0026gt; \u0026lt;div style={{ flex: 1 }}\u0026gt; {/* 此对应的是\u0026lt;Route path={\u0026#39;/\u0026#39;} element={\u0026lt;div/\u0026gt;}\u0026gt;\u0026lt;/Route\u0026gt; \u0026lt;Route path={\u0026#39;/demo2\u0026#39;} element={\u0026lt;App2/\u0026gt;}\u0026gt;\u0026lt;/Route\u0026gt; \u0026lt;Route path={\u0026#39;/demo3\u0026#39;} element={\u0026lt;App3/\u0026gt;}\u0026gt;\u0026lt;/Route\u0026gt;*/} \u0026lt;Outlet/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; } // page:user_add // page:user_delete // menu:system // menu:user // menu:product // operation:get // operation:update 这个不给 // // http://xxxxx.com/path const App = () =\u0026gt; { // autorun + set...\\ const forceUpdate = useForcesUpdate() useEffect(() =\u0026gt; { return autorun(() =\u0026gt; { userStore.permissions forceUpdate() }) }, []) return \u0026lt;div\u0026gt; {/*这是是用来给下面的Routes提供上下文的， 也就是说 Routes 放在这个里面才能正常工作 */} \u0026lt;HashRouter\u0026gt; \u0026lt;Nav\u0026gt;\u0026lt;/Nav\u0026gt; \u0026lt;Routes\u0026gt; //嵌套路由 \u0026lt;Route path={\u0026#39;/\u0026#39;} element={\u0026lt;Layout/\u0026gt;}\u0026gt; \u0026lt;Route path={\u0026#39;/\u0026#39;} element={hasPermission(\u0026#39;root\u0026#39;) ? \u0026lt;RootLayout/\u0026gt; : \u0026lt;CommonLayout/\u0026gt;}\u0026gt; \u0026lt;Route path={\u0026#39;/\u0026#39;} element={\u0026lt;div/\u0026gt;}\u0026gt;\u0026lt;/Route\u0026gt; \u0026lt;Route path={\u0026#39;/demo2\u0026#39;} element={\u0026lt;App2/\u0026gt;}\u0026gt;\u0026lt;/Route\u0026gt; \u0026lt;Route path={\u0026#39;/demo3\u0026#39;} element={\u0026lt;App3/\u0026gt;}\u0026gt;\u0026lt;/Route\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;Route path={\u0026#39;/api2\u0026#39;} element={\u0026lt;Layout/\u0026gt;}\u0026gt; \u0026lt;Route path={\u0026#39;/\u0026#39;} element={\u0026lt;div/\u0026gt;}\u0026gt;\u0026lt;/Route\u0026gt; { // 条件判断是否渲染路由 hasPermission(\u0026#34;user:add\u0026#34;) ? \u0026lt;Route path={\u0026#39;/demo2\u0026#39;} element={\u0026lt;App2/\u0026gt;}\u0026gt;\u0026lt;/Route\u0026gt; : null } \u0026lt;Route path={\u0026#39;/demo3\u0026#39;} element={\u0026lt;App3/\u0026gt;}\u0026gt;\u0026lt;/Route\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;/Routes\u0026gt; \u0026lt;/HashRouter\u0026gt; \u0026lt;/div\u0026gt; } 关于页面跳转 1 2 3 const goto = () =\u0026gt; { navigate(\u0026#39;/path/demo1\u0026#39;) } ","date":"2024-07-03T16:36:49+08:00","permalink":"https://example.com/p/react%E5%B8%B8%E5%8F%91%E7%94%9F%E7%9A%84%E5%9D%91/","title":"React常发生的坑"},{"content":"关于文件的定义 能读能写就是文件\n那些可读可写 1 2 3 4 5 6 // File* // stdout //控制太输出 // stdin //控制台输入 // stderr //控制台报错 // bytes.Buffer // net.Conn 关于net例子 1 2 3 4 5 listen, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:5000\u0026#34;) //listen.RemoteAddr().String() open, _ := os.Open(\u0026#34;./read.txt\u0026#34;) io.Copy(listen, open) 读文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //Open只读 open, _ := os.Open(\u0026#34;./read.txt\u0026#34;) //第一个参数为文件路径,第二个参数控制文件的打开方式,第三个参数控制文件模式\toutFile, err := os.OpenFile(\u0026#34;./out.txt\u0026#34;, os.O_WRONLY|os.O_CREATE, 0755) if err != nil { return } //记得关了 defer outFile.Close() //缓冲读操作 reader := bufio.NewReader(open) for i := 0; i \u0026lt; 10; i++ { line, _, _ := reader.ReadLine() fmt.Println(string(line)) } //适合小文件 all, err := io.ReadAll(open) fmt.Println(string(all), err) //适合大文件，出现大文件一次读不完的情况，就用这种读法 var buf = make([]byte, 1\u0026lt;\u0026lt;10) for { n, err := open.Read(buf) if n == 0 { break } if err != nil { return } fmt.Println(string(buf[:n])) } io.Copy 关于io.Copy，它可以操作任何可读可写的文件\n使用方法 1 io.Copy(目标文件, 源文件) 例子 1 2 3 4 5 6 io.Copy(os.Stdout, open) //创建一个文件 create, _ := os.Create(\u0026#34;./tmp.txt\u0026#34;) //将读取的内容open写入文件create io.Copy(create, open) ","date":"2024-07-03T16:34:46+08:00","permalink":"https://example.com/p/io.copy%E7%9A%84%E7%94%A8%E6%B3%95/","title":"Io.Copy的用法"},{"content":"事务 把多操作绑定在一起，如果一个操作失败则全部操作失败，数据回滚。\n例子 1 2 3 4 5 6 db.Transaction(func(tx *gorm.DB) error { // 在事务中执行一些 db 操作（从这里开始，您应该使用 \u0026#39;tx\u0026#39; 而不是 \u0026#39;db\u0026#39;） if err := tx.Create(\u0026amp;Animal{Name: \u0026#34;Giraffe\u0026#34;}).Error; err != nil { // 返回任何错误都会回滚事务 return err } ","date":"2024-07-03T16:32:48+08:00","permalink":"https://example.com/p/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9A%E4%B9%89/","title":"事务的定义"},{"content":"锁 关于锁是为安全考虑如若发生多线程同时操作的情况可以更安全的处理数据，类似于给同时的数据库操作排个序\n关于锁的分类 读锁： 其他人可以一起读， 但是不能写 写锁： 其他人什么都干不了\n关于数据库锁的操作 锁 Lock\n1 select * from user_moneys where id = 1 for update ; 加上for update后 在此语句commit提交之前需要等待，commit提交之后才能进行其他语句\n1 2 select *from user_moneys where id =1 for update; select *from user_moneys where id= 2 for update; 1 2 select *from user_moneys where id =2 for update; select *from user_moneys where id= 3 for update; 1 2 select *from user_moneys where id =3 for update; select *from user_moneys where id= 1 for update; 会形成死锁\n还有其他等方式（还没学） 互斥锁 1 2 sync.Mutex var lock sync.Mutex 单机的，只能在当前进程里（在不同线程{协程}中上锁）用的锁,保证协程中的数据\n例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func Incr() { //var tmp = 0 for i := 0; i \u0026lt; 100000; i++ { lock.Lock() mp[0] = mp[0] + 1 lock.Unlock() //tmp += 1 //count += 1 } //count += tmp wg.Done() } func main2() { begin := time.Now() var n = 50 wg.Add(n) for i := 0; i \u0026lt; n; i++ { go Incr() } wg.Wait() // 10000 * 5 fmt.Println(mp, time.Now().Sub(begin)) } 也可以这样,稍微快点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func Incr() { //var tmp = 0 lock.Lock() for i := 0; i \u0026lt; 100000; i++ { mp[0] = mp[0] + 1 //tmp += 1 //count += 1 } lock.Unlock() //count += tmp wg.Done() } func main2() { begin := time.Now() var n = 50 wg.Add(n) for i := 0; i \u0026lt; n; i++ { go Incr() } wg.Wait() // 10000 * 5 fmt.Println(mp, time.Now().Sub(begin)) } 保证了单个进程中的数据\n单纯的上下锁并不能保证数据的安全性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // sync.Mutex var lock sync.Mutex var lock_map = map[string]*sync.Mutex{} //安全上锁 func lockByName(name string) { if _, exists := lock_map[name]; !exists { lock.Lock() if _, exists := lock_map[name]; !exists { lock_map[name] = \u0026amp;sync.Mutex{} } lock.Unlock() } lock_map[name].Lock() } //下锁 func unlockByName(name string) { lock_map[name].Unlock() // 释放 name 对应的锁 } 分布式锁 面试问的比较多，有redis（面试常问）、etcd。\nredis redis可以在不同进程中上锁，而单机锁只能在进程中的不同线程（协程）中上锁\n1 2 3 1. 单线程 所以不存在多线程并发问题 2. 大致可以理解成是一个哈希表（map\u0026lt;string,void*\u0026gt;） 3. 内存数据库， 所有数据存在内存中 常被用于 1 2 1. 分布式锁 2. 缓存 关于操作命令 1 2 3 4 5 6 7 8 9 10 11 12 13 ### keys * //查看所有已经创立的键 ### set key value //创建一个键，value为键值内容 ### set x 1 ex（expire） 1 //创建一个名为“下”的键，键值为1，此键1秒后过期（ex的单位是秒） ### incr key //key+=1 ### decr key //key-=1 ### setnx key value //插入一个键和键值，如果此键已存在则返回0，可用于上锁操作 ### del key //删除这个键 ### get key //获取键值 ### publish channe //向一个频道发送消息（如果没人监听则发送失败） ### subscribe channe //监听一个频道 ### lpush key value //类似于链表，在链表（key）的左边插入一个值 ### rpush key value //同理，向右边插入一个值 ### lrange key 0 -1 //查看链表全部，-1是链表最后的位置 具体操作例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 client := redis.NewClient(\u0026amp;redis.Options{ //Addr: \u0026#34;127.0.0.1:6379\u0026#34;, }) //setnx一个键为x，键值为1，1分钟后过期 x := client.SetNX(context.Background(), \u0026#34;x\u0026#34;, \u0026#34;1\u0026#34;, time.Minute) for { x := client.SetNX(context.Background(), \u0026#34;x\u0026#34;, \u0026#34;1\u0026#34;, time.Minute) //fmt.Println(x.Val()) if x.Val() { break } time.Sleep(time.Millisecond * 50) } fmt.Println(\u0026#34;上锁成功\u0026#34;) client.Del(context.Background(), \u0026#34;x\u0026#34;) //监听 subscribe := client.Subscribe(context.Background(), \u0026#34;ch1\u0026#34;) channel := subscribe.Channel() ","date":"2024-07-03T16:28:14+08:00","permalink":"https://example.com/p/%E9%94%81/","title":"锁"},{"content":"关于前端的知识点 撑满屏幕高度 1 height: 100vh; 1 2 calc可以动态计算尺寸 style={{ minWidth: \u0026#39;calc(1920px * 0.8)\u0026#39; }} 1 2 根据设置调整子元素 child 的宽高比 aspectRatio: \u0026#39;1/1\u0026#39; border borderRadius: 百分比和像素的区别 borderRadius在设置宽高一致的时候50%（像素则是半径）才是正园，否则是椭圆。在设置borderRadius圆角时最好使用像素来设置\n1 \u0026lt;div style={{borderRadius: 25,}}\u0026gt; 关于border和outline的区别 border是即存在又显示，outline是显示但不存在，在一些情况下可能会影响元素的尺寸或者位置，而outline不会影响\n1 2 3 4 5 6 7 8 //错误例子 \u0026lt;div style={{ display: \u0026#34;flex\u0026#34;, flexWrap: \u0026#34;wrap\u0026#34; }}\u0026gt; \u0026lt;div style={{ width:\u0026#39;50% \u0026#39;,border: \u0026#39;20px solid red\u0026#39;, height: 200 }}\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style={{ width:\u0026#39;50% \u0026#39;,border: \u0026#39;20px solid red\u0026#39;, height: 200 }}\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; //以下为效果 ","date":"2024-07-03T16:22:56+08:00","permalink":"https://example.com/p/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/","title":"前端笔记"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block 1 \u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-07T00:00:00Z","permalink":"https://example.com/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo theme Stack supports the creation of interactive image galleries using Markdown. It\u0026rsquo;s powered by PhotoSwipe and its syntax was inspired by Typlog.\nTo use this feature, the image must be in the same directory as the Markdown file, as it uses Hugo\u0026rsquo;s page bundle feature to read the dimensions of the image. External images are not supported.\nSyntax 1 ![Image 1](1.jpg) ![Image 2](2.jpg) Result Photo by mymind and Luke Chesser on Unsplash\n","date":"2023-08-26T00:00:00Z","image":"https://example.com/p/image-gallery/2_hubce42636ecacc1a380b462f3110efcec_37455_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/image-gallery/","title":"Image gallery"},{"content":"For more details, check out the documentation.\nBilibili video Tencent video YouTube video Generic video file Your browser doesn't support HTML5 video. Here is a link to the video instead. Gist GitLab Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Photo by Codioful on Unsplash\n","date":"2023-08-25T00:00:00Z","image":"https://example.com/p/shortcodes/cover_huec3c3e34981507583e214021ad1b9a4b_12942_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/shortcodes/","title":"Shortcodes"},{"content":"Stack has built-in support for math typesetting using KaTeX.\nIt\u0026rsquo;s not enabled by default side-wide, but you can enable it for individual posts by adding math: true to the front matter. Or you can enable it side-wide by adding math = true to the params.article section in config.toml.\nInline math This is an inline mathematical expression: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n1 $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$ Block math $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n1 2 3 $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi),e^{2 \\pi i \\xi x},d\\xi $$\n1 2 3 $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ ","date":"2023-08-24T00:00:00Z","permalink":"https://example.com/p/math-typesetting/","title":"Math Typesetting"}]